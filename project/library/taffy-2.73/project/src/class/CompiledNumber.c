//
// This file is part of Taffy, a mathematical programming language.
// Copyright (C) 2016-2017 Arithmagic, LLC
//
// Taffy is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Taffy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

const char *__compiledNumber =    "package org.taffy.core.maths\n"
    "\n"
    "import org.taffy.core.maths.ComplexNumber\n"
    "import org.taffy.core.exception.*\n"
    "\n"
    "atomic class Number\n"
    "{\n"
    "    (@@) number: _numberString base: _base\n"
    "    {\n"
    "        if (_base < 0 or _base > 16)\n"
    "        {\n"
    "            throw [IndexOutOfBoundsException index: _base]\n"
    "        }\n"
    "\n"
    "        base = 1\n"
    "        result = 0\n"
    "        const hexMap = (\"0\" => 0,\n"
    "                        \"1\" => 1,\n"
    "                        \"2\" => 2,\n"
    "                        \"3\" => 3,\n"
    "                        \"4\" => 4,\n"
    "                        \"5\" => 5,\n"
    "                        \"6\" => 6,\n"
    "                        \"7\" => 7,\n"
    "                        \"8\" => 8,\n"
    "                        \"9\" => 9,\n"
    "                        \"A\" => 10,\n"
    "                        \"a\" => 10,\n"
    "                        \"B\" => 11,\n"
    "                        \"b\" => 11,\n"
    "                        \"C\" => 12,\n"
    "                        \"c\" => 12,\n"
    "                        \"D\" => 13,\n"
    "                        \"d\" => 13,\n"
    "                        \"E\" => 14,\n"
    "                        \"e\" => 14,\n"
    "                        \"F\" => 15,\n"
    "                        \"f\" => 15)\n"
    "\n"
    "        for (a = [_numberString length] - 1; a >= 0; a--)\n"
    "        {\n"
    "            value = hexMap[_numberString[a]]\n"
    "\n"
    "            if (value == nil)\n"
    "            {\n"
    "                throw [IndexOutOfBoundsException index: value]\n"
    "            }\n"
    "\n"
    "            result += value * base\n"
    "            base *= _base\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "    (@@) withDigitLimit: _limit\n"
    "                     do: _block\n"
    "    #breakthrough\n"
    "    {\n"
    "        // we really need == false\n"
    "        if ([Number pushDigitLimit: _limit] == false)\n"
    "        {\n"
    "            return false\n"
    "        }\n"
    "\n"
    "        __result = [_block call]\n"
    "        Number popDigitLimit\n"
    "        return (__result)\n"
    "    }\n"
    "\n"
    "    (@@) formattedNumber: _number\n"
    "    {\n"
    "        return [Number formattedNumber: _number style: 'american]\n"
    "    }\n"
    "\n"
    "    (@@) formattedNumber: _number style: _style\n"
    "    {\n"
    "        dotSplits = nil\n"
    "\n"
    "        if (_style == 'american)\n"
    "        {\n"
    "            dotSplits = [_number split: \".\"]\n"
    "        }\n"
    "        else if (_style == 'british)\n"
    "        {\n"
    "            dotSplits = [_number split: \",\"]\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            throw [InvalidFormattedNumberException newWithNumber: _number\n"
    "                                                           style: _style]\n"
    "        }\n"
    "\n"
    "        if ([dotSplits size] > 2)\n"
    "        {\n"
    "            throw [InvalidFormattedNumberException newWithNumber: _number\n"
    "                                                           style: _style]\n"
    "        }\n"
    "\n"
    "        left = dotSplits[0]\n"
    "        right = nil\n"
    "\n"
    "        // check past the decimal point\n"
    "        if ([dotSplits size] == 2)\n"
    "        {\n"
    "            right = dotSplits[1]\n"
    "\n"
    "            if (! [right isNumeric])\n"
    "            {\n"
    "                throw [InvalidFormattedNumberException newWithNumber: _number\n"
    "                                                               style: _style]\n"
    "            }\n"
    "        }\n"
    "\n"
    "        // now split the left\n"
    "        lefts = nil\n"
    "\n"
    "        if (_style == 'american)\n"
    "        {\n"
    "            lefts = [left split: \",\"]\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            lefts = [left split: \".\"]\n"
    "        }\n"
    "\n"
    "        if ([lefts[0] length] > 3)\n"
    "        {\n"
    "           throw [InvalidFormattedNumberException newWithNumber: _number\n"
    "                                                          style: _style]\n"
    "        }\n"
    "\n"
    "        size = [lefts size]\n"
    "\n"
    "        for (a = 1; a < size; a++)\n"
    "        {\n"
    "            if ([lefts[a] length] != 3)\n"
    "            {\n"
    "                throw [InvalidFormattedNumberException newWithNumber: _number\n"
    "                                                               style: _style]\n"
    "            }\n"
    "        }\n"
    "\n"
    "        numberString = \"\"\n"
    "\n"
    "        lefts each: ^{ <_left>\n"
    "            numberString += _left\n"
    "        }\n"
    "\n"
    "        if (right != nil)\n"
    "        {\n"
    "            numberString += \".\" + right\n"
    "        }\n"
    "\n"
    "        return [kernel eval: numberString]\n"
    "    }\n"
    "\n"
    "    (@) #operator(^): _other\n"
    "    #synchronizedRead,\n"
    "    #const\n"
    "    {\n"
    "        if ([_other class] == ComplexNumber)\n"
    "        {\n"
    "            real = [_other real]\n"
    "            imaginary = [_other imaginary]\n"
    "\n"
    "            return (self^real\n"
    "                    * (cos(imaginary * ln(self))\n"
    "                       + i * sin(imaginary * ln(self))))\n"
    "        }\n"
    "        else if (self < 0\n"
    "                 and [_other class] == Number\n"
    "                 and ((_other < 1\n"
    "                      and _other > 0)\n"
    "                     or ! [_other isWhole]))\n"
    "        {\n"
    "            left = [ComplexNumber createFromNumber: self]\n"
    "            right = [ComplexNumber createFromNumber: _other]\n"
    "            return (left^right)\n"
    "        }\n"
    "        else if (self < 0\n"
    "                 and [_other class] == Number\n"
    "                 and _other < 0)\n"
    "        {\n"
    "            return (1 / (self^(-1 * _other)))\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            return ([self raise: _other])\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) #operator(~=): _arguments\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        other = _arguments[0]\n"
    "\n"
    "        if ([other class] == ComplexNumber)\n"
    "        {\n"
    "            real = [other real]\n"
    "            imaginary = [other imaginary]\n"
    "\n"
    "            if (self == NaN and (real == NaN or imaginary == NaN))\n"
    "            {\n"
    "                return (true)\n"
    "            }\n"
    "            else if (! (imaginary ~= 0))\n"
    "            {\n"
    "                return (false)\n"
    "            }\n"
    "\n"
    "            newArguments = [real, _arguments[1]]\n"
    "            return ([self deltaEquals: newArguments])\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            return ([self deltaEquals: _arguments])\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) #operator(==): _other\n"
    "    #synchronizedRead,\n"
    "    #const\n"
    "    {\n"
    "        if ([_other class] == Number)\n"
    "        {\n"
    "            return ([self trulyEquals: _other])\n"
    "        }\n"
    "        else if ([_other class] == ComplexNumber)\n"
    "        {\n"
    "            real = [_other real]\n"
    "            imaginary = [_other imaginary]\n"
    "\n"
    "            if (self == NaN and (real == NaN or imaginary == NaN))\n"
    "            {\n"
    "                return (true)\n"
    "            }\n"
    "            else if (imaginary == 0)\n"
    "            {\n"
    "                return ([self trulyEquals: real])\n"
    "            }\n"
    "            else\n"
    "            {\n"
    "                return (false)\n"
    "            }\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            return ([self trulyEquals: _other])\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) testComplexOperation: _realOperation\n"
    "                         for: _value\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        if ([_value class] == ComplexNumber)\n"
    "        {\n"
    "            real = [_value real]\n"
    "            imaginary = [_value imaginary]\n"
    "\n"
    "            return ([self perform: _realOperation with: [real]]\n"
    "                    + ([self perform: _realOperation with: [imaginary]]) * i)\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            return ([self perform: _realOperation with: [_value]])\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) #operator(%): _other\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self testComplexOperation: \"realModulus:\"\n"
    "                                       for: _other])\n"
    "    }\n"
    "\n"
    "    (@) #operator(<<): _other\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self testComplexOperation: \"realLeftShift:\"\n"
    "                                       for: _other])\n"
    "    }\n"
    "\n"
    "    (@) #operator(>>): _other\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self testComplexOperation: \"realRightShift:\"\n"
    "                                       for: _other])\n"
    "    }\n"
    "\n"
    "    (@) #operator(&): _other\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self testComplexOperation: \"realBitAnd:\"\n"
    "                                       for: _other])\n"
    "    }\n"
    "\n"
    "    (@) #operator(|): _other\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self testComplexOperation: \"realBitOr:\"\n"
    "                                       for: _other])\n"
    "    }\n"
    "\n"
    "    (@) #operator(^^): _other\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self testComplexOperation: \"realBitXOr:\"\n"
    "                                       for: _other])\n"
    "    }\n"
    "\n"
    "    (@) asBase: _base\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        if (! [_base isWhole])\n"
    "        {\n"
    "            throw [NeedIntegerException newObject: _base]\n"
    "        }\n"
    "\n"
    "        if (! [self isWhole])\n"
    "        {\n"
    "            throw [NeedIntegerException newObject: self]\n"
    "        }\n"
    "\n"
    "        if (_base < 0 or _base > 16)\n"
    "        {\n"
    "            throw [IndexOutOfBoundsException index: _base]\n"
    "        }\n"
    "\n"
    "        digitLimit = [self digitLimit]\n"
    "\n"
    "        if (digitLimit == 0)\n"
    "        {\n"
    "            digitLimit = 24\n"
    "        }\n"
    "\n"
    "        const hexMap = (0 => \"0\",\n"
    "                        1 => \"1\",\n"
    "                        2 => \"2\",\n"
    "                        3 => \"3\",\n"
    "                        4 => \"4\",\n"
    "                        5 => \"5\",\n"
    "                        6 => \"6\",\n"
    "                        7 => \"7\",\n"
    "                        8 => \"8\",\n"
    "                        9 => \"9\",\n"
    "                        10 => \"A\",\n"
    "                        11 => \"B\",\n"
    "                        12 => \"C\",\n"
    "                        13 => \"D\",\n"
    "                        14 => \"E\",\n"
    "                        15 => \"F\")\n"
    "        result = \"\"\n"
    "\n"
    "        Number withDigitLimit: digitLimit do: ^{\n"
    "            left = upSelf\n"
    "\n"
    "            while (left > 0)\n"
    "            {\n"
    "                 result = \"#[hexMap[floor(left % _base)]]\" + result\n"
    "                 left = floor(left / _base)\n"
    "            }\n"
    "\n"
    "            if (result == \"\")\n"
    "            {\n"
    "                result = \"0\"\n"
    "            }\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "    (@) asBinary\n"
    "    #const\n"
    "    {\n"
    "        return \"0b\" + [self asBase: 2]\n"
    "    }\n"
    "\n"
    "    (@) asHex\n"
    "    #const\n"
    "    {\n"
    "        return \"0x\" + [self asBase: 16]\n"
    "    }\n"
    "}\n"
;