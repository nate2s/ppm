//
// This file is part of Taffy, a mathematical programming language.
// Copyright (C) 2016-2017 Arithmagic, LLC
//
// Taffy is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Taffy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

const char *__compiledMatrix =    "package org.taffy.core.maths\n"
    "\n"
    "import org.taffy.core.exception.*\n"
    "\n"
    "class Matrix\n"
    "{\n"
    "  @protected\n"
    "    (@) isMatchingVector: _matrix\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return (([self rowCount] == 1\n"
    "                 and [_matrix rowCount] == 1)\n"
    "                or ([self columnCount] == 1\n"
    "                    and [_matrix columnCount] == 1))\n"
    "    }\n"
    "\n"
    "    (@) arbitraryMathOperation: _operation\n"
    "                        object: _object\n"
    "    #const\n"
    "    {\n"
    "        result = [self copy]\n"
    "\n"
    "        self eachIndex: ^{ <x, y>\n"
    "             result[x, y] = [kernel eval: \"upSelf[x, y] #[_operation] _object\"]\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "  @public\n"
    "    (@) #operator(+): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self mathOperation: \"#operator(+):\"\n"
    "                             object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(-): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self mathOperation: \"#operator(-):\"\n"
    "                             object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(/): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \"/\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(<<): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \"<<\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(>>): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \">>\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(%): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \"%\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(&): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \"&\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(|): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \"|\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(^^): _object\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return ([self arbitraryMathOperation: \"^^\"\n"
    "                                      object: _object])\n"
    "    }\n"
    "\n"
    "    (@) #operator(^): _count\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        result = self\n"
    "\n"
    "        for (count = _count; count > 1; count--)\n"
    "        {\n"
    "            result = result * self\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "    (@) dimensions\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        return [[self rowCount], [self columnCount]]\n"
    "    }\n"
    "\n"
    "    (@) #operator([]): _index\n"
    "    #const,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        if ([self rowCount] == 1)\n"
    "        {\n"
    "            return self[0, _index]\n"
    "        }\n"
    "        else if ([self columnCount] == 1)\n"
    "        {\n"
    "            return self[_index, 0]\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            throw [IndexOutOfBoundsException index: _index]\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) #operator([]=): _values\n"
    "    #const\n"
    "    {\n"
    "        index = _values[0]\n"
    "        value = _values[1]\n"
    "\n"
    "        if ([self rowCount] == 1)\n"
    "        {\n"
    "            self[0, index] = value\n"
    "        }\n"
    "        else if ([self columnCount] == 1)\n"
    "        {\n"
    "            self[index, 0] = value\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            throw [IndexOutOfBoundsException index: index]\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) each: _block\n"
    "    #const,\n"
    "    #breakthrough,\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        __rows__ = [self rowCount]\n"
    "        __columns__ = [self columnCount]\n"
    "\n"
    "        for (__row__ = 0; __row__ < __rows__; __row__++)\n"
    "        {\n"
    "            for (__column__ = 0; __column__ < __columns__; __column__++)\n"
    "            {\n"
    "                [_block callWith: [self[__row__, __column__]]]\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // row and column counts are unchangeable so no synchronization is needed\n"
    "    (@) eachIndex: _block\n"
    "    #breakthrough,\n"
    "    #const\n"
    "    {\n"
    "        __rows__ = [self rowCount]\n"
    "        __columns__ = [self columnCount]\n"
    "\n"
    "        for (__row__ = 0; __row__ < __rows__; __row__++)\n"
    "        {\n"
    "            for (__column__ = 0; __column__ < __columns__; __column__++)\n"
    "            {\n"
    "                [_block callWith: [__row__, __column__]]\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    (@) dot: _matrix\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        result = 0\n"
    "\n"
    "        if ([self isMatchingVector: _matrix])\n"
    "        {\n"
    "            self eachIndex: ^{ <x, y>\n"
    "                 result += upSelf[x, y] * _matrix[x, y]\n"
    "            }\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            throw new NeedVectorException\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "    (@) hadamard: _matrix\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        result = [Matrix createWithRows: [self rowCount]\n"
    "                                columns: [self columnCount]]\n"
    "\n"
    "        if ([self isMatchingVector: _matrix])\n"
    "        {\n"
    "            self eachIndex: ^{ <x, y>\n"
    "                 result[x, y] = upSelf[x, y] * _matrix[x, y]\n"
    "            }\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            throw new NeedVectorException\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "    (@) magnitude\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        result = 0\n"
    "\n"
    "        if ([self rowCount] == 1\n"
    "            or [self columnCount] == 1)\n"
    "        {\n"
    "            self each: ^{ <value>\n"
    "                 result += value^2\n"
    "            }\n"
    "\n"
    "            result = sqrt(result)\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            throw new NeedVectorException\n"
    "        }\n"
    "\n"
    "        return result\n"
    "    }\n"
    "\n"
    "    (@) getRow: _index\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        columns = [self columnCount]\n"
    "        result = [Matrix createWithRows: 1 columns: columns]\n"
    "\n"
    "        for (a = 0; a < columns; a++)\n"
    "        {\n"
    "            result[0, a] = self[_index, a]\n"
    "        }\n"
    "\n"
    "        return (result)\n"
    "    }\n"
    "\n"
    "    (@) getColumn: _index\n"
    "    #synchronizedRead\n"
    "    {\n"
    "        rows = [self rowCount]\n"
    "        result = [Matrix createWithRows: rows columns: 1]\n"
    "\n"
    "        for (a = 0; a < rows; a++)\n"
    "        {\n"
    "            result[a, 0] = self[a, _index]\n"
    "        }\n"
    "\n"
    "        return (result)\n"
    "    }\n"
    "\n"
    "    (@) vectorize: _function\n"
    "    #breakthrough\n"
    "    {\n"
    "        return [[self copy] vectorize!: _function]\n"
    "    }\n"
    "\n"
    "    (@) vectorize!: _function\n"
    "    {\n"
    "        [self eachIndex: ^{ <row, count>\n"
    "           upSelf[row, count] = _function(upSelf[row, count])\n"
    "        }]\n"
    "\n"
    "        return self\n"
    "    }\n"
    "}\n"
;